#' Taxme: A package for handling NCBI taxonomy IDs
#'
#' @docType package
#' @name taxme
NULL


#' Environment keeping cached NCBI tree
#' @keywords internal
cacheEnv <- new.env(parent=emptyenv())

#' Logging helper
#' @importFrom utils flush.console
#' @keywords internal
logger <- function(...) {
  cat(sprintf(...), sep='', file=stderr())
  flush.console()
}

#' Download NCBI Taxonomy Files
#'
#' Downloads the NCBI Taxonomy dump and unpacks it into a temporary directory.
#'
#' @param destdir Directory to unpack files into. A temporary directory will be
#'   created if this is not provided.
#' @param baseurl URL from which taxdump should be downloaded
#' @param fname Filename to expect at \code{baseurl}
#'
#' @return Directory name
#'
#' @seealso \code{\link{read.ncbi}}
#'
#' @examples
#' dirname <- download.ncbitax()
#'
#' @importFrom utils download.file
#' @export
download.ncbitax <- function(
  destdir,
  baseurl = "ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/",
  fname = "taxdump.tar.gz"
) {
  if (missing(destdir)) {
    destdir <- paste0(tempdir(), "/ncbitax/")
  }
  dir.create(destdir)
  download.file(paste0(baseurl, fname), paste0(destdir, fname))
  system(paste0("tar -C ", destdir, " -xzf ", paste0(destdir,fname)))
  unlink(paste0(destdir, fname))
  destdir
}

#' Load NCBI Taxonomy Tree
#'
#' Prepares the  NCBI taxonomy for use with the other functions in \link{taxme}.
#'
#' @param dir Optional directory containing the unpackaged NCBI taxonomy dump
#'   files names.dmp, nodes.dmp and merged.dmp. If not provided, files will be
#'   downloaded using \code{\link{download.ncbitax}} automatically.
#' @param use.cache Since downloading and parsing the dumps from NCBI is time
#'   consuming, read.ncbi will cache the final data.table in the file
#'   "\code{ncbitax.Rds}" in the CWD. If this parameter is set to \code{FALSE},
#'   an existing cache file will be ignored.
#' @param clear.cache Delete an existing "ncbitax.Rds" before proceeding to
#'   prepare data structure if set to \code{TRUE}.
#' @param env.cache If \code{TRUE} (default), \code{read.ncbi} will try to
#'   return the taxonomy object cached from its last invocation.
#'
#' @return Returns a data.table containing NCBI taxonomy. The table is also
#'   cached internally for use with the functions within this package.
#'
#' @examples
#'
#' ncbi <- read.ncbi()
#'
#' @seealso \code{\link{ncbi.lineage}}
#'
#' @import data.table
#' @export
read.ncbi <- function(dir, use.cache=TRUE, clear.cache=FALSE, env.cache=TRUE) {
  if (env.cache && !is.null(cacheEnv$ncbi)) {
    return (cacheEnv$ncbi)
  }
  if (length(list.files(pattern="ncbitax.Rds"))) {
    if (clear.cache) {
      unlink("ncbitax.Rds")
    } else if (use.cache) {
      cacheEnv$ncbi <- readRDS("ncbitax.Rds")
      return (cacheEnv$ncbi)
    }
  }
  if (missing(dir)) {
    dir <- download.ncbitax()
    unlink_dir <- TRUE
  } else {
    unlink_dir <- FALSE
  }
  logger("reading nodes...\n")
  nodes <- fread(paste0(dir, 'nodes.dmp'),
                 select=c(1,3,5),
                 col.names=c('tax_id', 'parent_id','rank'),
                 key="tax_id")

  logger("reading merged nodes...\n")
  merged <- fread(paste0(dir, "/merged.dmp"),
                  select=c(1,3),
                  col.names = c('tax_id', 'parent_id'),
                  key="tax_id")
  merged$rank <- "None"

  logger("reading names...\n")
  tnames <- fread(paste0(dir, "/names.dmp"),
                  quote="",
                  select=c(1,3,7),
                  col.names= c('tax_id', 'name', 'name_cls'),
                  key="name_cls")
  tnames <- tnames["scientific name"]
  setkey(tnames, "tax_id")
  tnames$name_cls <- NULL

  if (unlink_dir) {
    unlink(dir, recursive=TRUE)
  }

  nodes <- rbind(merged, nodes)
  nodes <- nodes[order(nodes$tax_id), ]
  ncbi <- merge(nodes, tnames, all.x=TRUE, by="tax_id")
  ncbi$rank <- as.factor(ncbi$rank)
  ncbi <- data.table(ncbi)
  setkey(ncbi, tax_id)
  setindex(ncbi, name)
  setindex(ncbi, parent_id)
  setindex(ncbi, rank)

  if (use.cache) {
    saveRDS(ncbi, file="ncbitax.Rds")
  }
  cacheEnv$ncbi = ncbi
  ncbi
}

#' Computes lineage from NCBI tax_id
#'
#' @param tax_id NCBI taxid(s). Passing a vector is highly recommended over
#'   calling \code{ncbi.lineage} multiple times.
#' @param ncbi Explicitly provide NCBI taxonomy as generated by
#'   \code{\link{read.ncbi}}.
#' @return List of NCBI taxids. If \code{tax_id} is a vector, a list of lists
#'   will be returned with all lists filled to matching lengths using the id of
#'   the root node (1).
#'
#' @examples
#'
#' ncbi.lineage(9606)
#'
#' @seealso \code{\link{ncbi.path}}
#' @import data.table
#' @export
#'
ncbi.lineage <- function(tax_id, ncbi=read.ncbi()) {
  lids = list(tax_id)
  setDT(lids, "tax_id")
  lin = list()
  lin <- append(lin, lids)
  while(max(lids) != 1) {
    parents <- ncbi[lids, parent_id]
    lids <- list(parents)
    setDT(lids, "tax_id")
    lin <- append(lin, lids)
  }
  data.table::transpose(lin)
}

#' Computes taxonomy path from NCBI tax_id
#'
#' @param tax_id NCBI taxid(s). Passing a vector is highly recommended over
#'   calling \code{ncbi.path} multiple times.
#' @param ranks Filter resulting vector to only include the listed ranks.
#'   Passing \code{"standard"} will filter the lineages to contain only the
#'   levels species, genus, family, order, class, phylum and superkingdom
#'   (domain).
#' @param ncbi Explicitly provide NCBI taxonomy as generated by
#'   \code{\link{read.ncbi}}.
#'
#' @return List of NCBI taxonomy node names. If \code{tax_id} is a vector, a
#'   list of lists will be returned.
#'
#' @examples
#' ncbi.path(9606)
#' ncbi.path(9606, ranks = "standard")
#' ncbi.path(9606, ranks = c("class", "phylum"))
#'
#' @seealso \code{\link{ncbi.lineage}}
#'
#' @import data.table
#' @export
ncbi.path <- function(tax_id,
                      ranks,
                      ncbi=read.ncbi()
                      ) {
  if (missing(ranks)) {
    lapply(ncbi.lineage(tax_id),
           function(x) ncbi[list(x), name, rank])
  } else {
    if (ranks == "standard") {
      ranks <- c("species", "genus", "family", "order", "class", "phylum", "superkingdom")
    }
    ranks <- factor(ranks, levels=levels(ncbi$rank))
    lapply(ncbi.lineage(tax_id),
           function(x) ncbi[list(x)][list(ranks), on="rank", name, rank])
  }
}

#' Yield summary group name for taxids
#'
#' Computes summary group names for a set of tax ids such that the group names
#' are either in the set provided by \code{nodes} or at one of the ranks provided
#' by \code{ranks}.
#'
#' @param taxid Set of NCBI taxonomy IDs
#' @param ranks Vector of rank names
#' @param nodes Vector of clade names
#' @param ncbi Explicitly provide NCBI taxonomy as generated by
#'   \code{\link{read.ncbi}}.
#' @return Vector of clade names
#'
#' @examples
#'
#' ncbi.group(c(9606, 22, 9), ranks=c("superkingdom"),
#'            nodes=c("Homo sapiens", "synthetic construct"))
#'
#' @export
ncbi.group <- function(taxid, ranks=c(),
                       nodes=c(),
                       ncbi=read.ncbi()) {
  terminal = ncbi[1]
  if (length(ranks) > 0) {
    terminal <- rbind(ncbi[list(ranks), on="rank"], terminal)
  }
  if (length(nodes) > 0) {
    terminal <- rbind(ncbi[list(nodes), on="name"], terminal)
  }
  terminal$name <- as.factor(terminal$name)
  setkey(terminal, "tax_id")

  f<-function(x) x %in% terminal$tax_id
  x<-ncbi.lineage(taxid)
  x<-vapply(x, Find, f=f, 0)
  terminal[list(x), name]
}
